//////////////////////////////////////////////////////////////////////////////////
// Engineer:      (Generated by Gemini)
// Create Date:   10/07/2025
// Module Name:   entering_numbers
// Description:
// Implements a state machine to allow the user to input two numbers (num1, num2)
// using the Basys3 directional buttons.
// - UP/DOWN: Increment/decrement the currently selected digit.
// - LEFT/RIGHT: Move the cursor to the previous/next digit.
// - CENTER: Confirm the current number and move to the next, or finish entry.
//////////////////////////////////////////////////////////////////////////////////
module entering_numbers(
    input freq625m, btnC, btnU, btnL, btnR, btnD,
    output reg [16:0] num1 = 0,
    output reg [16:0] num2 = 0,
    output reg done = 0
);
    // State definitions
    localparam S_NUM1_ENTRY = 0, S_NUM2_ENTRY = 1, S_DONE = 2;
    reg [1:0] state = S_NUM1_ENTRY;

    // Internal state for digit selection and value
    reg [2:0] selected_digit = 0; // 0-4 for a 5-digit number
    reg [16:0] current_num = 0;
    reg [3:0] d4, d3, d2, d1, d0; // Decoded digits of current_num

    // Helper task to update the BCD digits from the binary current_num
    task update_digits;
    begin
        d0 = current_num % 10;
        d1 = (current_num / 10) % 10;
        d2 = (current_num / 100) % 10;
        d3 = (current_num / 1000) % 10;
        d4 = (current_num / 10000) % 10;
    end
    endtask

    // Main state machine
    always @(posedge freq625m) begin
        case(state)
            S_NUM1_ENTRY: begin
                done <= 0;
                num1 <= current_num;
                if (btnC) begin
                    state <= S_NUM2_ENTRY;
                    current_num <= num2; // Load num2 for editing, or 0 if first time
                    selected_digit <= 0;
                end
            end
            S_NUM2_ENTRY: begin
                done <= 0;
                num2 <= current_num;
                if (btnC) begin
                    state <= S_DONE;
                end
            end
            S_DONE: begin
                done <= 1;
                // If btnC is pressed again, reset to start a new calculation
                if (btnC) begin
                    state <= S_NUM1_ENTRY;
                    current_num <= 0;
                    num1 <= 0;
                    num2 <= 0;
                    selected_digit <= 0;
                end
            end
        endcase
    end

    // Digit modification and cursor logic (runs in parallel to FSM)
    always @(posedge freq625m) begin
        if (state != S_DONE) begin
            // Cursor movement
            if (btnL) selected_digit <= (selected_digit == 4) ? 0 : selected_digit + 1;
            if (btnR) selected_digit <= (selected_digit == 0) ? 4 : selected_digit - 1;

            // Update digits from binary number
            update_digits;

            // Increment/decrement logic based on selected digit
            if (btnU) begin
                case(selected_digit)
                    0: if (d0 < 9) current_num <= current_num + 1;
                    1: if (d1 < 9) current_num <= current_num + 10;
                    2: if (d2 < 9) current_num <= current_num + 100;
                    3: if (d3 < 9) current_num <= current_num + 1000;
                    4: if (d4 < 9) current_num <= current_num + 10000;
                endcase
            end
            if (btnD) begin
                case(selected_digit)
                    0: if (d0 > 0) current_num <= current_num - 1;
                    1: if (d1 > 0) current_num <= current_num - 10;
                    2: if (d2 > 0) current_num <= current_num - 100;
                    3: if (d3 > 0) current_num <= current_num - 1000;
                    4: if (d4 > 0) current_num <= current_num - 10000;
                endcase
            end
        end
    end

endmodule
